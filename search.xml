<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>axios五种请求</title>
      <link href="/ardentupo/2022/03/10/%E5%89%8D%E7%AB%AF/axios%E4%BA%94%E7%A7%8D%E8%AF%B7%E6%B1%82/"/>
      <url>/ardentupo/2022/03/10/%E5%89%8D%E7%AB%AF/axios%E4%BA%94%E7%A7%8D%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>axios五种请求</p><p>　　1.get: 一般多用于获取数据　　</p><p>不带参数    　　<br>方式一: axios({ methods: ‘get’, url: ‘&#x2F;ulr’ })<br>方式二: axios.get(‘&#x2F;url’)</p><p>带参数<br>    方式一: axios.get(‘&#x2F;url’, {params: {id: 12}})  &#x2F;&#x2F;请求的地址实际为 localhost:8080&#x2F;url?id&#x3D;12<br>    方式二: axios({<br>                   methods: ‘get’,<br>                   url: ‘url’,<br>                   params: {<br>                        id:12<br>                   }<br>               })<br>2.post: 主要提交表单数据和上传文件</p><p> let data &#x3D; {}<br> let config &#x3D; {}<br> 方式一:  axios.post(‘&#x2F;url’,data,config)</p><p> 方式二:  axios({<br>           methods: ‘post’,<br>           url: ‘&#x2F;url’,<br>           data: data,<br>           config: config<br>          })　　　　<br>其中 data可以有两种格式form-data(图片上传,文件上传)  applicition&#x2F;json（目前比较流行）<br>上面两种方法 都是 appliction&#x2F;json格式　　　　<br>如下为: form-data<br>　　　　let formData &#x3D; new FormData()<br>       let data &#x3D; {<br>　　　　　　id: 12<br>　　　　}<br>       for (let key in data) {<br>　　　　    formData.append(key, data[key]) &#x2F;&#x2F;创建form-data格式数据<br>       }<br>　　　　 axios({<br>　　　　　　methods: ‘post’,<br>　　　　    url: ‘&#x2F;url’,<br>　　　　　　data: formData<br>　　　　 })<br>　该请求发出之后可以在浏览器中查看此次请求的request header里面content-type: 为 form-data形式</p><p><strong>form-data、x-www-form-urlencoded：需要使用@RequestParam</strong></p><p><strong>application&#x2F;json： 需要使用@RequestBody</strong></p><p>因为这里我用axios处理的 contentType 为 application&#x2F;x-www-form-urlencoded<br>而且后端是用 @RequestParam 来接收前端传过来的参数的，所以post传参的时候用的是 qs.stringify(data) ,若后台使用 @RequestBody，则应该使用 JSON.stringify(data) 来转化格式。其导致这个坑的最主要原因就是后端中 @RequestParam 和**@RequestBody**的差别所致</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex 中辅助函数mapState的基本用法详解</title>
      <link href="/ardentupo/2022/03/10/%E5%89%8D%E7%AB%AF/vuex%20%E4%B8%AD%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0mapState%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/ardentupo/2022/03/10/%E5%89%8D%E7%AB%AF/vuex%20%E4%B8%AD%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0mapState%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="vuex-中辅助函数mapState的基本用法详解"><a href="#vuex-中辅助函数mapState的基本用法详解" class="headerlink" title="vuex 中辅助函数mapState的基本用法详解"></a><a href="https://www.cnblogs.com/aidixie/p/14977850.html">vuex 中辅助函数mapState的基本用法详解</a></h1><h3 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a><code>mapState</code> 辅助函数</h3><p>　　当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性，让你少按几次键：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">/**</span><br><span class="line">    vuex的核心管理对象模块:store</span><br><span class="line"> */</span><br><span class="line">import Vue from &#x27;vue&#x27;;</span><br><span class="line">import Vuex from &#x27;vuex&#x27;;</span><br><span class="line">import vuexTest from &#x27;./modules/vuexTest&#x27;;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">// 状态对象</span><br><span class="line">const state = &#123; // 初始化状态 这里放置的状态可以被多个组件共享</span><br><span class="line">    count: 1,</span><br><span class="line">    count1: 1,</span><br><span class="line">    count2: 2,</span><br><span class="line">    count3: 3,</span><br><span class="line">    name: &#x27;daming&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">const mutations = &#123;&#125;;</span><br><span class="line">const actions = &#123;&#125;;</span><br><span class="line">const getters = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    state, // 状态</span><br><span class="line">    mutations, // 包含多个更新state函数的对象</span><br><span class="line">    actions, // 包含多个队形事件回调函数的对象</span><br><span class="line">    getters, // 包含多个getter计算属性函数的对象</span><br><span class="line">    modules: &#123; // 模块化</span><br><span class="line">        vuexTest</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　1、在界面或组件中不使用mapState获取vuex中state的状态</p><p>　　虽然将所有的状态放入Vuex，会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态，比如temp变量,hello, number作为组件的局部状态。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- test.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;example&quot;&gt;</span><br><span class="line">    &#123;&#123;count&#125;&#125;</span><br><span class="line">    &#123;&#123;name&#125;&#125;</span><br><span class="line">    &#123;&#123;helloName&#125;&#125;</span><br><span class="line">    &#123;&#123;addNumber&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      hello: &#x27;hello&#x27;,</span><br><span class="line">      number: 1,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line"></span><br><span class="line">    // 由于 Vuex 的状态存储是响应式的，所以可以使用计算属性来获得某个状态</span><br><span class="line">    // 通过下面的计算属性，就可以在当前组件中访问到count,name，helloName，addNumber 在模板中我们通过大括号符号打印出来，当然这些可以在vue中使用，比如在watch中监听，在mounted中使用</span><br><span class="line"></span><br><span class="line">    // 下面的计算属性涉及到了vuex管理的状态</span><br><span class="line">    count() &#123; // 这实际上是ES6中对象的简化写法 完整写法是 count: function &#123; return this.$store.state.count &#125;</span><br><span class="line">      return this.$store.state.count</span><br><span class="line">    &#125;,</span><br><span class="line">    name() &#123; // 这实际上是ES6中对象的简化写法 完整写法是 name: function &#123; return this.$store.state.count &#125;</span><br><span class="line">      return this.$store.state.count</span><br><span class="line">    &#125;,</span><br><span class="line">    helloName: function (state) &#123; // 为了能够使用 `this` 获取局部状态，必须使用常规函数，不能使用箭头函数</span><br><span class="line">      return this.hello + this.$store.state.name</span><br><span class="line">    &#125;,</span><br><span class="line">    addNumber: function (state) &#123; // 为了能够使用 `this` 获取局部状态，必须使用常规函数，不能使用箭头函数</span><br><span class="line">      return this.number + this.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">    // 但有一个问题</span><br><span class="line">    // 当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。比如上面的name(),count(),helloName(),显得重复，代码冗长</span><br><span class="line">    // 为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键：</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">     helloName(newVal,oldVal)&#123;</span><br><span class="line">         console.log(newVal);</span><br><span class="line">         console.log(oldVal);</span><br><span class="line">     &#125; </span><br><span class="line">  &#125;,</span><br><span class="line">  mounted()&#123;</span><br><span class="line">      console.log(this.helloName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　2、在组件、界面中使用mapState获取vuex中state的数据</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- test.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;example&quot;&gt;</span><br><span class="line">    &#123;&#123;count&#125;&#125;</span><br><span class="line">    &#123;&#123;count1&#125;&#125;</span><br><span class="line">    &#123;&#123;repeatCount&#125;&#125;</span><br><span class="line">    &#123;&#123;count3&#125;&#125;</span><br><span class="line">    &#123;&#123;name&#125;&#125;</span><br><span class="line">    &#123;&#123;helloName&#125;&#125;</span><br><span class="line">    &#123;&#123;addNumber&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      hello: &#x27;hello&#x27;,</span><br><span class="line">      number: 1,</span><br><span class="line">      count2: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 数组形式</span><br><span class="line">     * 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。</span><br><span class="line">     * */</span><br><span class="line">    ...mapState([&quot;count&quot;, &quot;name&quot;]),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对象形式</span><br><span class="line">     */</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      count, // 这种就是count:&quot;count&quot;, 的简写</span><br><span class="line">      count1: &quot;count1&quot;,</span><br><span class="line">      repeatCount: &quot;count2&quot;, // 当组件中与vuex中的字符已经出现重复时，使用 repeatCount 来映射 store.state.count2</span><br><span class="line">      count3: (state) =&gt; &#123; // 映射 count3 为 store.state.conut3的值</span><br><span class="line">        return state.count3</span><br><span class="line">      &#125;,</span><br><span class="line">      helloName: function (state) &#123; // 为了能够使用 `this` 获取局部状态，必须使用常规函数，不能使用箭头函数</span><br><span class="line">        return this.hello + state.name</span><br><span class="line">      &#125;,</span><br><span class="line">      addNumber: function (state) &#123; // 为了能够使用 `this` 获取局部状态，必须使用常规函数，不能使用箭头函数</span><br><span class="line">        return this.number + state.count</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    helloName(newVal, oldVal) &#123;</span><br><span class="line">      console.log(newVal);</span><br><span class="line">      console.log(oldVal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(this.helloName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　3、modules的vuexTest模块中state数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**`` ``* vuexTest.js`` ``* modules 中的数据`` ``*/``export ``default` `&#123;``  ``namespaced: ``true``,``  ``state: &#123;``    ``moduleVal: 1,``    ``moduleName: ``&quot;战战兢兢&quot;``  ``&#125;,``  ``getters: &#123;``  ``&#125;,``  ``mutations: &#123;``  ``&#125;,``  ``actions: &#123;``  ``&#125;``&#125;</span><br></pre></td></tr></table></figure><p>　　4、在界面或组件中不使用mapState获取模块modules vuexTest中state的状态</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- module test.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;example&quot;&gt;</span><br><span class="line">    &#123;&#123;moduleVal&#125;&#125;</span><br><span class="line">    &#123;&#123;moduleName&#125;&#125;</span><br><span class="line">    &#123;&#123;moduleNameOther&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      hello: &#x27;hello&#x27;,</span><br><span class="line">      number: 1,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    moduleVal()&#123;</span><br><span class="line">        return this.$store.state.vuexTest.moduleVal</span><br><span class="line">    &#125;,</span><br><span class="line">    moduleName()&#123;</span><br><span class="line">        return this.$store.state.vuexTest.moduleVal</span><br><span class="line">    &#125;,</span><br><span class="line">    moduleNameOther()&#123;</span><br><span class="line">        // 当组件中与vuex中的字符已经出现重复时，使用 moduleNameOther 来映射 store.state.vuexTest.moduleName</span><br><span class="line">        return this.$store.state.vuexTest.moduleVal </span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    helloName(newVal, oldVal) &#123;</span><br><span class="line">      console.log(newVal);</span><br><span class="line">      console.log(oldVal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(this.addNumber);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>　　5、在界面或组件中使用mapState获取模块modules vuexTest中state的状态</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- module test.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;example&quot;&gt;</span><br><span class="line">    &#123;&#123;moduleVal&#125;&#125;</span><br><span class="line">    &#123;&#123;moduleName&#125;&#125;</span><br><span class="line">    &#123;&#123;moduleNameOther&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapState &#125; from &#x27;vuex&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      hello: &#x27;hello&#x27;,</span><br><span class="line">      number: 1,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 数组形式</span><br><span class="line">     * 当映射的计算属性的名称与 与模块中vuexTest中state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组，</span><br><span class="line">     * */</span><br><span class="line">    ...mapState(&quot;vuexTest&quot;, [&quot;moduleVal&quot;, &quot;moduleName&quot;]),</span><br><span class="line">    // &quot;vuexTest&quot; 指向模块vuexTest，&quot;moduleVal&quot;表示store.vuexTest.moduleVal</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对象形式</span><br><span class="line">     */</span><br><span class="line">    // 第一种对象方式</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      moduleVal: &quot;vuexTest/moduleVal&quot;,</span><br><span class="line">      moduleNameOther: &quot;vuexTest/moduleName&quot; // 表示 moduleNameOther 映射到vuexTest模块中moduleName</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    ...mapState(&quot;vuexTest&quot;, &#123;</span><br><span class="line">      moduleVal, // 这种就是moduleVal:&quot;moduleVal&quot;, 的简写</span><br><span class="line">      moduleName: &quot;moduleName&quot;,</span><br><span class="line">      moduleNameOther: &quot;moduleName&quot;, // 当组件中与vuex中的字符已经出现重复时，使用 moduleNameOther 来映射 store.state.vuexTest.moduleName</span><br><span class="line">      moduleVal: (state) =&gt; &#123; // 映射 moduleVal 为 store.state.vuexTest.moduleVal的值</span><br><span class="line">        return state.moduleVal</span><br><span class="line">      &#125;,</span><br><span class="line">      helloName: function (state) &#123; // 为了能够使用 `this` 获取局部状态，必须使用常规函数，不能使用箭头函数</span><br><span class="line">        return this.hello + state.moduleName</span><br><span class="line">      &#125;,</span><br><span class="line">      addNumber(state) &#123; // 为了能够使用 `this` 获取局部状态，必须使用常规函数，不能使用箭头函数</span><br><span class="line">        return this.number + state.moduleVal</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    helloName(newVal, oldVal) &#123;</span><br><span class="line">      console.log(newVal);</span><br><span class="line">      console.log(oldVal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(this.addNumber);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端接口交互</title>
      <link href="/ardentupo/2022/03/10/%E5%89%8D%E7%AB%AF/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3%E4%BA%A4%E4%BA%92/"/>
      <url>/ardentupo/2022/03/10/%E5%89%8D%E7%AB%AF/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<h1 id="前后端接口交互"><a href="#前后端接口交互" class="headerlink" title="前后端接口交互"></a>前后端接口交互</h1><h4 id="一、axios发送get、post请求的几种方式"><a href="#一、axios发送get、post请求的几种方式" class="headerlink" title="一、axios发送get、post请求的几种方式"></a>一、axios发送get、post请求的几种方式</h4><h5 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h5><ol><li><p>采用字符串拼接的方式进行传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.axios.post(`https://..../updateAddress?addressName=$&#123;this.addressName&#125;&amp;houseNumber=$&#123;this.houseNumber&#125;&amp;userName=$&#123;this.userName&#125;&amp;userPhone=$&#123;this.userPhone&#125;&amp;isdefault=$&#123;this.isDefault&#125;&amp;addressId=$&#123;this.addressId&#125;`)</span><br><span class="line">            .then(response =&gt; &#123;</span><br><span class="line">                //...</span><br><span class="line">            &#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ol><p>2、json对象提交数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let data = &#123;</span><br><span class="line">        &#x27;user&#x27;: &#123; &#x27;id&#x27;: `$&#123;this.$user.getUserId()&#125;` &#125;,</span><br><span class="line">        &#x27;hideFlag&#x27;: &#x27;1&#x27;,</span><br><span class="line">        &#x27;content&#x27;: this.content,</span><br><span class="line">        &#x27;pictureUrl&#x27;: this.imgUrl</span><br><span class="line">      &#125;</span><br><span class="line">      this.axios.post(&#x27;https://...../submitFeedback&#x27;, data)</span><br><span class="line">        .then(this.postFeedBackSucc)</span><br><span class="line">        .catch((e) =&gt; &#123;</span><br><span class="line">          console.log(e)</span><br><span class="line">        &#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>3、通过FormData表单形式传递参数</p><p>示例一：json对象字符串传递数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let data = new FormData()</span><br><span class="line">      data.append(&#x27;json&#x27;, JSON.stringify(&#123; &#x27;userId&#x27;: `45435465464` &#125;))</span><br><span class="line">      this.axios.post(&#x27;https://houqin.eooker.com/delivery/a/shop/merchantAPI/markList&#x27;, data, &#123;</span><br><span class="line">        header: &#123;</span><br><span class="line">          &#x27;Content-Type&#x27;: &#x27;multipart/form-data&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">        .then(response =&gt; &#123;</span><br><span class="line">            //.....</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch((e) =&gt; &#123;</span><br><span class="line">          console.log(e)</span><br><span class="line">        &#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>示例二：通过键值对的表单形式传递数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var formData=new FormData();</span><br><span class="line">formData.append(&#x27;user&#x27;,123456);</span><br><span class="line">formData.append(&#x27;pass&#x27;,12345678);</span><br><span class="line"> </span><br><span class="line">axios.post(&quot;/notice&quot;,formData)</span><br><span class="line">     .then((res) =&gt; &#123;return res&#125;)</span><br><span class="line">     .catch((err) =&gt; &#123;return err&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h4><ol><li>字符串拼接方式（不推荐）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_self.axios.get(`https://...../pay?orderNumber=$&#123;_self.orderNumber&#125;&amp;openId=$&#123;_self.$user.getOpenId()&#125;`).then(result =&gt; &#123;</span><br><span class="line">        //.....</span><br><span class="line">      &#125;).catch(err =&gt; &#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">      &#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>\2. 通过 params对象传递数据（推荐）<br><strong>params参数必写 , 如果没有参数传{}也可以</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> let data = &#123; userId: this.$user.getUserId(), start: 0, size: 10 &#125;</span><br><span class="line">    this.axios.get(&#x27;https://..../listByUserId&#x27;, &#123; params: &#123; &#x27;json&#x27;: data &#125; &#125;)</span><br><span class="line">    .then(response =&gt; &#123;</span><br><span class="line">        //.....</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch((e) =&gt; &#123;</span><br><span class="line">        console.log(e)</span><br><span class="line">    &#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="ResquestMapping-ResponseBody，PathVariable，-ResquestParam的用法"><a href="#ResquestMapping-ResponseBody，PathVariable，-ResquestParam的用法" class="headerlink" title="@ResquestMapping,@ResponseBody，PathVariable，@ResquestParam的用法"></a>@ResquestMapping,@ResponseBody，PathVariable，@ResquestParam的用法</h1><p>[(9条消息) @ResquestMapping,@ResponseBody，PathVariable，@ResquestParam的用法_melody_sy博客-CSDN博客](<a href="https://blog.csdn.net/s740556472/article/details/55804050?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=@PathVarable">https://blog.csdn.net/s740556472/article/details/55804050?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=@PathVarable</a> @ResquestParam @R&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-55804050.pc_search_result_control_group&amp;spm&#x3D;1018.2226.3001.4187)</p><p><a href="https://cloud.tencent.com/developer/article/1683822">springmvc中@PathVariable和@RequestParam的区别 - 云+社区 - 腾讯云 (tencent.com)</a></p><p>@ResponseBody是作用在方法上的，@ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】。<br>注意：在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据。@RequestBody 将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。</p><p>后台 Controller类中对应的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/login.do&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Object login(String name, String password, HttpSession session) &#123;</span><br><span class="line">user = userService.checkLogin(name, password);</span><br><span class="line">session.setAttribute(&quot;user&quot;, user);</span><br><span class="line">return new JsonResult(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml格式 或者 json等】封装为对应的 JavaBean 对象，<br>封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上。<br>如上面的登录后台代码可以改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/login.do&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Object login(@RequestBody User loginUuser, HttpSession session) &#123;</span><br><span class="line">user = userService.checkLogin(loginUser);</span><br><span class="line">session.setAttribute(&quot;user&quot;, user);</span><br><span class="line">return new JsonResult(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>restful接口设计规范总结</title>
      <link href="/ardentupo/2022/03/10/JAVA/restful%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/"/>
      <url>/ardentupo/2022/03/10/JAVA/restful%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="restful接口设计规范总结"><a href="#restful接口设计规范总结" class="headerlink" title="restful接口设计规范总结"></a>restful接口设计规范总结</h1><h3 id="一、重要概念："><a href="#一、重要概念：" class="headerlink" title="一、重要概念："></a>一、重要概念：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">REST,即Representational State Transfer的缩写。我对这个词组的翻译是&quot;表现层状态转化&quot;。</span><br><span class="line"></span><br><span class="line">**Resource**（资源） ：对象的单个实例。 例如，一只动物。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</span><br><span class="line"></span><br><span class="line">**集合**：对象的集合。 例如，动物。</span><br><span class="line"></span><br><span class="line">**第三方**：使用我们接口的开发者</span><br><span class="line"></span><br><span class="line">**表现层（Representation）**</span><br><span class="line"></span><br><span class="line">&quot;资源&quot;是一种信息实体，它可以有多种外在表现形式。我们把&quot;资源&quot;具体呈现出来的形式，叫做它的&quot;表现层&quot;（Representation）。</span><br><span class="line"></span><br><span class="line">**状态转化（State Transfer）**</span><br><span class="line"></span><br><span class="line">访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生&quot;状态转化&quot;（State Transfer）。而这种转化是建立在表现层之上的，所以就是&quot;表现层状态转化&quot;。</span><br><span class="line"></span><br><span class="line">客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</span><br><span class="line"></span><br><span class="line">它们分别对应四种基本操作：**GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。**</span><br><span class="line"></span><br><span class="line">比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</span><br><span class="line"></span><br><span class="line">URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的&quot;.html&quot;后缀名是不必要的，因为这个后缀名表示格式，属于&quot;表现层&quot;范畴，而URI应该只代表&quot;资源&quot;的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对&quot;表现层&quot;的描述。</span><br></pre></td></tr></table></figure><p>综合上面的解释，我们总结一下什么是RESTful架构：</p><p>（1）每一个URI代表一种资源；</p><p>（2）客户端和服务器之间，传递这种资源的某种表现层；</p><p>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p><h3 id="二、REST接口规范"><a href="#二、REST接口规范" class="headerlink" title="二、REST接口规范"></a>二、REST接口规范</h3><h4 id="1、动作"><a href="#1、动作" class="headerlink" title="1、动作"></a>1、动作</h4><p>GET （SELECT）：从服务器检索特定资源，或资源列表。<br> POST （CREATE）：在服务器上创建一个新的资源。<br> PUT （UPDATE）：更新服务器上的资源，提供整个资源。<br> PATCH （UPDATE）：更新服务器上的资源，仅提供更改的属性。<br> DELETE （DELETE）：从服务器删除资源。</p><p>首先是四个半种动作：<br> post、delete、put&#x2F;patch、get<br> 因为put&#x2F;patch只能算作一类，所以将patch归为半个。</p><p>另外还有有两个较少知名的HTTP动词：<br> HEAD - 检索有关资源的元数据，例如数据的哈希或上次更新时间。<br> OPTIONS - 检索关于客户端被允许对资源做什么的信息。</p><h4 id="2、路径（接口命名）"><a href="#2、路径（接口命名）" class="headerlink" title="2、路径（接口命名）"></a>2、路径（接口命名）</h4><p>路径又称”终点”（endpoint），表示API的具体网址。</p><p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p><p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p><p>接口尽量使用名词，禁止使用动词，下面是一些例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET         /zoos：列出所有动物园</span><br><span class="line">POST        /zoos：新建一个动物园</span><br><span class="line">GET         /zoos/ID：获取某个指定动物园的信息</span><br><span class="line">PUT         /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH       /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line">DELETE      /zoos/ID：删除某个动物园</span><br><span class="line">GET         /zoos/ID/animals：列出某个指定动物园的所有动物</span><br><span class="line">DELETE      /zoos/ID/animals/ID：删除某个指定动物园的指定动物</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/getAllCars</span><br><span class="line">/createNewCar</span><br><span class="line">/deleteAllRedCars</span><br></pre></td></tr></table></figure><p>再比如，某个URI是&#x2F;posts&#x2F;show&#x2F;1，其中show是动词，这个URI就设计错了，正确的写法应该是&#x2F;posts&#x2F;1，然后用GET方法表示show。</p><p>正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：</p><blockquote><p>POST &#x2F;transaction HTTP&#x2F;1.1<br> 　Host: 127.0.0.1<br> 　from&#x3D;1&amp;to&#x3D;2&amp;amount&#x3D;500.00</p></blockquote><p>理清资源的层次结构，比如业务针对的范围是学校，那么学校会是一级资源(&#x2F;school)，老师(&#x2F;school&#x2F;teachers)，学生(&#x2F;school&#x2F;students)就是二级资源。</p><h4 id="3、版本（Versioning）"><a href="#3、版本（Versioning）" class="headerlink" title="3、版本（Versioning）"></a>3、版本（Versioning）</h4><p>应该将API的版本号放入URL。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//api.example.com/v1/</span></span><br></pre></td></tr></table></figure><p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p><h4 id="4、过滤信息（Filtering）"><a href="#4、过滤信息（Filtering）" class="headerlink" title="4、过滤信息（Filtering）"></a>4、过滤信息（Filtering）</h4><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。<br> 下面是一些常见的参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">limit</span>=10：指定返回记录的数量</span><br><span class="line">?offset=10：指定返回记录的开始位置。</span><br><span class="line">?page_number=2&amp;page_size=100：指定第几页，以及每页的记录数。</span><br><span class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?animal_type_id=1：指定筛选条件</span><br><span class="line">参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，</span><br><span class="line">GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</span><br></pre></td></tr></table></figure><h4 id="5、状态码（Status-Codes）"><a href="#5、状态码（Status-Codes）" class="headerlink" title="5、状态码（Status Codes）"></a>5、状态码（Status Codes）</h4><p>状态码范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1xx 信息，请求收到，继续处理。范围保留用于底层HTTP的东西，你很可能永远也用不到。</span><br><span class="line">2xx 成功，行为被成功地接受、理解和采纳</span><br><span class="line">3xx 重定向，为了完成请求，必须进一步执行的动作</span><br><span class="line">4xx 客户端错误，请求包含语法错误或者请求无法实现。范围保留用于响应客户端做出的错误，例如。他们提供不良数据或要求不存在的东西。这些请求应该是幂等的，而不是更改服务器的状态。</span><br><span class="line">5xx 范围的状态码是保留给服务器端错误用的。这些错误常常是从底层的函数抛出来的，甚至</span><br><span class="line">开发人员也通常没法处理，发送这类状态码的目的以确保客户端获得某种响应。</span><br><span class="line">当收到5xx响应时，客户端不可能知道服务器的状态，所以这类状态码是要尽可能的避免。</span><br></pre></td></tr></table></figure><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span> OK - <span class="selector-attr">[GET]</span>：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</span><br><span class="line"><span class="number">201</span> CREATED - <span class="selector-attr">[POST/PUT/PATCH]</span>：用户新建或修改数据成功。</span><br><span class="line"><span class="number">202</span> Accepted - <span class="selector-attr">[*]</span>：表示一个请求已经进入后台排队（异步任务）</span><br><span class="line"><span class="number">204</span> NO <span class="attribute">CONTENT</span> - <span class="selector-attr">[DELETE]</span>：用户删除数据成功。</span><br><span class="line"><span class="number">400</span> INVALID REQUEST - <span class="selector-attr">[POST/PUT/PATCH]</span>：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</span><br><span class="line"><span class="number">401</span> Unauthorized - <span class="selector-attr">[*]</span>：表示用户没有权限（令牌、用户名、密码错误）。</span><br><span class="line"><span class="number">403</span> Forbidden - <span class="selector-attr">[*]</span> 表示用户得到授权（与<span class="number">401</span>错误相对），但是访问是被禁止的。</span><br><span class="line"><span class="number">404</span> NOT FOUND - <span class="selector-attr">[*]</span>：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line"><span class="number">406</span> Not Acceptable - <span class="selector-attr">[GET]</span>：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</span><br><span class="line"><span class="number">410</span> Gone -<span class="selector-attr">[GET]</span>：用户请求的资源被永久删除，且不会再得到的。</span><br><span class="line"><span class="number">422</span> Unprocesable entity - <span class="selector-attr">[POST/PUT/PATCH]</span> 当创建一个对象时，发生一个验证错误。</span><br><span class="line"><span class="number">500</span> INTERNAL SERVER ERROR - <span class="selector-attr">[*]</span>：服务器发生错误，用户将无法判断发出的请求是否成功。</span><br><span class="line"><span class="number">502</span> 网关错误</span><br><span class="line"><span class="number">503</span> Service Unavailable</span><br><span class="line"><span class="number">504</span> 网关超时</span><br></pre></td></tr></table></figure><ol><li>request获取参数中文出现乱码</li></ol><p>原因:</p><p>汉字在不同的编码表中的码值不一样，那么在使用不同的编码表进行解码与编码操作时，就会出现乱码问题.</p><p>浏览器在提交的时候使用utf-8编码</p><p>Tomcat得到请求参数是使用iso8859-1进行了解码，封装到了request中。</p><p>在通过request获取请求信息就是乱码。</p><p>解决:</p><p>先使用iso8859-1进行编码</p><p>在使用utf-8进行解码</p><p>每个参数都要new才行(get,post方法都可行)</p><p>username&#x3D; new String(username.getBytes(“iso8859-1”),”utf-8”);</p><p>如果请求方式是POST,</p><p>可以直接使用request.setCharacterEncoding(“utf-8”);就可以解决。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>菜鸟的springboot常用注解总结</title>
      <link href="/ardentupo/2022/03/10/JAVA/%E8%8F%9C%E9%B8%9F%E7%9A%84springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/"/>
      <url>/ardentupo/2022/03/10/JAVA/%E8%8F%9C%E9%B8%9F%E7%9A%84springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>说明<br>@SpringBootApplication<br>@Component、@Service、@Controller、@Repository<br>@ResponseBody<br>@RestController<br>@AutoWired、@Qualifier、@Resource<br>@RequestMapping、@GetMapping、@PostMapping<br>@Value、@ConfigurationProperties、@PropertySource<br>@Configuration、@Bean<br>@RequestParam、@RequestBody、@PathVariable、@RequestHeader、@CookieValue<br>说明<br>更新时间：2020&#x2F;8&#x2F;12 22:14，更新了@RequestParam等注解<br>更新时间：2020&#x2F;8&#x2F;6 18:00，更新了@AutoWired等注解<br>更新时间：2020&#x2F;8&#x2F;2 17:32，更新了@SpringBootApplication等注解</p><p>本文主要对网上的springboot常见注解和自己本人在学习的过程中遇到的注解的一次总结，本文会持续更新，不断地扩充</p><p>本文仅为记录学习轨迹，如有侵权,联系删除</p><p>@SpringBootApplication<br>包含@Configuration、@EnableAutoConfiguration、@ComponentScan通常用在主类上；</p><p>相关注解    说明<br>@ComponentScan    用来自动扫描被这些注解标识的类，最终生成ioc容器里的bean，默认扫描范围是@ComponentScan注解所在配置类包及子包的类<br>@SpringBootConfiguration    与@Configuration作用相同，都是用来声明当前类是一个配置类，这里表明是springboot主类使用的配置类<br>@EnableAutoConfiguration    是springboot实现自动化配置的核心注解，通过这个注解把spring应用所需的bean注入容器中<br>@Component、@Service、@Controller、@Repository<br>这几个注解放在一起是因为功能基本一样的，都是将类注入到spring容器中，只不过它们使用的场景不同，被@Component,@Service,@Controller,@Repository注解标注的类，这些类会被纳入进spring容器中管理。</p><p>注解    说明<br>@Repository    持久层（dao）注入spring容器<br>@Service    业务逻辑层（server）注入spring容器<br>@Controller    控制层（controller）注入spring容器<br>@Component    普通pojo注入spring容器<br>@ResponseBody<br>@ResponseBody可以作用在方法上或类上，表示该方法的返回结果直接写入 HTTP response body 中，而不会被解析为跳转路径，即不会经过视图解析器，返回什么数据即在页面输入什么数据。</p><p>注解    说明<br>@ResponseBody    @ResponseBody的作用其实是将java对象转为json格式的数据。<br>测试如下</p><p>@RestController<br>该注解是@Controller和@ResponseBody的结合体，一般用于类，作用等于在类上面添加了@ResponseBody和@Controller</p><p>@AutoWired、@Qualifier、@Resource<br>这3个注解都是基于注解方式进行自动装配，在容器里面将查找到的bean返回，一般@AutoWired用得最多，@Qualifier则需要配合@AutoWired使用，@Resource则是可以通过名字进行自动装配</p><p>注解    说明<br>@AutoWired    @Autowired默认按类型装配，如果发现找到多个bean，则按照name方式比对，如果还有多个，则报出异常<br>@Qualifier    spring的注解，按名字注入 一般当出现两个及以上bean时,不知道要注入哪个，结合@AutoWired使用<br>@Resource    默认按名称注入例如@Resource(name &#x3D; “zhaozhao”)则根据name属性注入找不到则报错，若无name属性则根据属性名称注入，如果匹配不成功则按照类型匹配匹配不成功则报错。<br>@AutoWired</p><p>@Qualifier<br>当有一个接口的多个实现类时，只用@AutoWired会报错，因为它有多个接口的实现类，不知道你要找哪一个，这个时候就需要在注入bean的时候起个名字，然后用@Qualifier注解指定哪一个bean(按照名字注入与装配)</p><p>@Resource<br>该注解的使用相当于@AutoWired和@Qualifier配合使用的效果</p><p>@RequestMapping、@GetMapping、@PostMapping<br>这3个注解功能也是类似的，通过这3个注解来映射请求，也就是通过它来指定控制器可以处理哪些URL请求，用在方法上，可以通过配置的url进行访问</p><p>注解    说明<br>@RequestMapping    @RequestMapping（url），通过该注解就可以通过配置的url进行访问，方式可以是get或post请求，两种方式均可<br>@GetMapping    @GetMapping（url） ，功能类似的，只是这个限定了只能是Get请求<br>@PostMapping    @PostMapping（url），功能类似的，只是这个限定了只能是Post请求<br>@RequestMapping<br>发起get请求或者post请求都可以</p><p>@GetMapping<br>只能用get请求</p><p>@PostMapping<br>只能发起post请求</p><p>@Value、@ConfigurationProperties、@PropertySource<br>注解    说明<br>@Value    用于获取bean的属性，一般用于读取配置文件的数据，作用在变量上<br>@ConfigurationProperties    用于注入Bean属性，然后再通过当前Bean获取注入值，作用在类上<br>@PropertySource    用于指定要读取的配置文件，可以和@Value或@ConfigurationProperties配合使用<br>注意：@PropertySource不支持yml文件读取。</p><p>@Value<br>这里用yml配置文件进行演示，propres配置文件也是同样的效果，在application.yml配置文件里设置开发环境的的配置文件（dev），这样用@Value获取到的就是开发环境的配置文件的数据，切换成生产环境（pro）则获取到的是生产环境的数据</p><p>@ConfigurationProperties<br>该注解可以直接注入整个类的数据，作用于类</p><p>配置文件如下，这里使用pro环境</p><p>测试</p><p>@PropertySource</p><p>注意：@PropertySource不支持yml文件读取。<br>配置文件如下：people.properties</p><p>测试</p><p>当然@PropertySource还可以和@Value配合使用，即一个一个注入值。</p><p>@Configuration、@Bean<br>@Configuration作用于类上面，表明这是一个配置类，@Bean产生一个Bean对象加入Spring IOC容器</p><p>注意：@Configuration标注在类上，相当于把该类作为spring的xml配置文件中，作用为：配置spring容器(应用上下文)</p><p>注解    说明<br>@Configuration    作用于类上表示这是一个配置类，可理解为用spring的时候xml里面的&lt; beans&gt;标签<br>@Bean    产生bean对象加入容器，作用于方法，可理解为用spring的时候xml里面的标签<br>一般这两个注解同时配合使用</p><p>新建配置类，将User加入容器，并自定义生命周期</p><p>测试</p><p>@RequestParam、@RequestBody、@PathVariable、@RequestHeader、@CookieValue<br>这3个注解放在一起主要是经常在控制层用来接收参数的</p><p>注解    说明<br>@RequestParam    获取查询参数。即url?name&#x3D;这种形式<br>@PathVariable    获取路径参数。即url&#x2F;{id}这种形式。<br>@RequestParam    获取Body的参数，一般用于post获取参数<br>@RequestHeader    获取请求头的信息<br>@CookieValue    获取Cookie的信息<br>@RequestParam<br>@RequestParam主要用于接收url?后面的参数，get或post请求，只要后面的url?有参数都可以获取到对应的参数</p><p>@RequestParam注解有几个比较重要的属性，required 表示是否必须，默认为 true，必须。defaultValue 可设置请求参数的默认值。value 为接收url的参数名（相当于key值）。</p><p>示例代码如下</p><pre><code>@GetMapping(&quot;/requestParam&quot;)@ResponseBodypublic Map&lt;String, String&gt; requestParam(        UserDto userDto,//通过一个实体类来接收，字段名必须一致        @RequestParam(value = &quot;id&quot;, required = false) String userId,        @RequestParam(value = &quot;name&quot;, required = false) String userName,        @RequestParam(value = &quot;pageIndex&quot;, required = true, defaultValue = &quot;1&quot;) String pageIndex,        @RequestParam(value = &quot;pageSize&quot;, required = true, defaultValue = &quot;5&quot;) String pageSize) &#123;    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();    map.put(&quot;userDto&quot;,userDto.toString());    map.put(&quot;id&quot;, userId);    map.put(&quot;name&quot;, userName);    map.put(&quot;pageIndex&quot;, pageIndex);    map.put(&quot;pageSize&quot;, pageSize);    return map;&#125;</code></pre><p>运行</p><p>@PathVariable<br>该注解主要用于获取路径参数，像url&#x2F;{id}&#x2F;{name}这种形式的参数都可以，get获取post请求均可</p><p>示例代码如下：</p><pre><code>@PostMapping(&quot;/pathVariable/&#123;id&#125;/&#123;name&#125;&quot;)@ResponseBodypublic Map&lt;String, String&gt; pathVariable(        @PathVariable(name = &quot;id&quot;) String userId,        @PathVariable(name = &quot;name&quot;) String userName) &#123;    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();    map.put(&quot;id&quot;, userId);    map.put(&quot;name&quot;, userName);    return map;&#125;</code></pre><p>@RequestBody<br>该注解用于获取请求体数据（body）,get没有请求体，故而一般用于post请求</p><p>示例代码如下：</p><pre><code>@PostMapping(&quot;/test01&quot;)@ResponseBodypublic UserDto test01(@RequestBody UserDto userDto) &#123;    return userDto;&#125;@PostMapping(&quot;/test02&quot;)@ResponseBodypublic String test02(@RequestBody String str) &#123;    return str;&#125;</code></pre><p>运行结果</p><p>注意，如果要传多个参数过去只能将其封装成一个类，如果是出现了多个@RequestBody注解访问的时候会报400错误，例如下面这种代码就是错误的</p><pre><code>@PostMapping(&quot;/requestBody&quot;)@ResponseBodypublic Map&lt;String,String&gt; requestBody(        @RequestBody(required = true) String id,        @RequestBody(required = true) String name,        @RequestBody(required = false) String sex,        @RequestBody(required = false) String age        )&#123;    Map&lt;String,String&gt; map = new HashMap&lt;&gt;();    map.put(&quot;id&quot;,&quot;id&quot;);    map.put(&quot;name&quot;,&quot;name&quot;);    return map;&#125;</code></pre><p>@RequestHeader<br>示例代码如下</p><pre><code>@PostMapping(&quot;/requestHeader&quot;)@ResponseBodypublic String requestBody03(@RequestHeader(name = &quot;Content-Type&quot;) String contentType)&#123;    return contentType;&#125;</code></pre><p>运行结果</p><p>@CookieValue<br>由于postman模拟cookie本人不会弄，只能用别人的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/demo3&quot;)</span><br><span class="line">public void demo3(@RequestHeader(name = &quot;myHeader&quot;) String myHeader,</span><br><span class="line">        @CookieValue(name = &quot;myCookie&quot;) String myCookie) &#123;</span><br><span class="line">    System.out.println(&quot;myHeader=&quot; + myHeader);</span><br><span class="line">    System.out.println(&quot;myCookie=&quot; + myCookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lombok注解    应用场景<br>@Data    Getter、Setter、RequiredArgsConstructor、ToString、EqualsAndHashCode<br>@Table    当数据库的表名和实体类不一致时，name 属性可以指定数据库的表，这样实体类和数据库的表就可以有映射关系了<br>@NoArgsConstructor    无参构造方法<br>@AllArgsConstructor    有参构造方法<br>@Builder    类名.builder()就可以进行属性填充<br>@RequiredArgsConstructor(onConstructor &#x3D; @__(@Autowired))    注入场景<br>@Cleanup    关流</p><p>SpringBoot注解    应用场景<br>@RestControllere    Controller层<br>@Service    逻辑处理层<br>@@Repository    持久理层<br>@Component    自定义类，例如工具类<br>@GetMapping    GET请求<br>@PostMapping    POST请求<br>@ResponseBody    返回接json字符串处理<br>@PathVariable    url&#x2F;{参数}<br>@RestController    @Controller+@ResponseBody<br>@Autowired    注入<br>@Resource    注入<br>@SpringBootApplication    启动类注解<br>@MapperScan    扫描mybatis那些包里面的接口<br>@RequestParam    url?参数&#x3D;value<br>@Param ()    mybatis注解</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/ardentupo/2022/03/10/hello-world/"/>
      <url>/ardentupo/2022/03/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
